[
  {
    "objectID": "project.html",
    "href": "project.html",
    "title": "4  Project",
    "section": "",
    "text": "XXXX\nNew format of Excel-sheet to work better to import in RStudio. It includes one column with the samples name, replicate number, target compound, which adduct it was detected as, the measured Mass_To_Charge ratio (m/z), Retention time (RT), Drift time (DT), CCS, and detector count (Intensity). All the data obtained from UNIFI software.\nEach type of sample has its own sheet. Hence, the data shown in the Figure 1, are from measurements of one standard called StD B, whereas measurements of another standard has another sheet in the same Excel-file. The first sheet in the file is called Info and contains information of the samples. For example, StD B is measured in different concentrations (10, 50, 100, 300, and 500 ppb). In the data for StD B, the Sample Items are called StD_XX, where XX is the concentration. However, in Info, it is possible to find the name of the measurements (e.g. StD_10_240319), number of replicates, and which standard and concentration that was measured.\n\n\n\nFigure 1. Example of the format of the Excel sheet for imported data.\n\n\nImport libraries\n####\n\n#data_hrms &lt;- read_excel()"
  },
  {
    "objectID": "project.html#loading-of-libraries",
    "href": "project.html#loading-of-libraries",
    "title": "4  Project",
    "section": "4.1 Loading of libraries",
    "text": "4.1 Loading of libraries"
  },
  {
    "objectID": "project.html#functions",
    "href": "project.html#functions",
    "title": "4  Project",
    "section": "4.2 Functions",
    "text": "4.2 Functions\n\n\\(MassError[ppm]=\\frac{\\textit{m/z}_{theretical}-\\mathit{m/z}_{measured}}{\\mathit{m/z}_{theoretical}}*10^6\\)\n\n\n#Function to calculate the Mass Error with three digits\nmass_error &lt;- function(mz_theoretical,mz_meaured){\n  mass_error &lt;- round((mz_theoretical-mz_meaured)/mz_theoretical*10^6, digits=3)\n  return(mass_error)\n}\n\n\n\\(SEM=\\frac{SD}{\\sqrt{N}}\\) , SD= Standard Deviation, N=number of samples\n\n\n#Function to calculate the Standard Error of the Mean (SEM)\nstderror &lt;- function(x){\n  round(sd(x, na.rm =TRUE)/sqrt(length(x)),4)\n}\n\n\nFunction for a Bar plot\n\n\nbar_plot &lt;- function(dataframe, xvalue, yvalue, fillvalue, error) {\n  xvalue &lt;- enquo(xvalue)   # Capture xvalue as a quosure\n  yvalue &lt;- enquo(yvalue)   # Capture yvalue as a quosure\n  fillvalue &lt;- enquo(fillvalue)   # Capture fillvalue as a quosure\n  error &lt;- enquo(error)   # Capture error as a quosure\n  \n  p &lt;- ggplot(data=dataframe, aes_string(x=quo_name(xvalue), y=quo_name(yvalue), fill=quo_name(fillvalue)))+\n    geom_bar(stat = \"identity\",position=position_dodge(0.9))+\n    geom_errorbar(aes(ymin=!!yvalue -!!error, \n                      ymax=!!yvalue +!!error), \n                  width=0.3, colour=\"black\", size=0.8,position=position_dodge(0.9))+\n    scale_fill_npg()+\n    theme_minimal()+\n    theme(\n      panel.background = element_rect(fill = \"white\"),  # Set white background\n      panel.grid.major = element_blank(),  # Remove grid lines\n      panel.grid.minor = element_blank(),  # Remove grid lines\n      axis.text = element_text(size = 9),  # Increase font size of axis text\n      axis.title.y = element_text(size = 9,face = \"bold\"),  # Make y-axis label bold and italic\n      axis.text.y = element_text(color = \"black\", size = 9),  # Make x-axis text bold\n      axis.title.x = element_text(size = 10,face = \"bold\"),\n      axis.text.x = element_text(color = \"black\", size = 9, angle = 45, hjust=1),  # Make x-axis text bold\n      axis.ticks.x = element_line(color = \"black\"),  # Add ticks to x-axis in black color\n      axis.ticks.y = element_line(color = \"black\"),  # Add ticks to y-axis in black color\n      plot.margin = margin(0.5, 0.5, 0.4, 0.5, \"cm\"),  # Set plot margins\n      legend.text=element_text(size=9),\n      legend.background = element_rect(fill=\"white\",\n                                     size=0.5, linetype=\"solid\", \n                                     colour =\"black\"),\n      legend.title = element_blank(),\n  )\nreturn(p)\n}\n\n\nFunction for a Scatter plot\n\n\nscatter_plot &lt;- function(dataframe, xvalue, yvalue, colorvalue, error) {\n  xvalue &lt;- enquo(xvalue)   # Capture xvalue as a quosure\n  yvalue &lt;- enquo(yvalue)   # Capture yvalue as a quosure\n  colorvalue &lt;- enquo(colorvalue)   # Capture colorvalue as a quosure\n  error &lt;- enquo(error)   # Capture error as a quosure\n  \n  p &lt;- ggplot(data=dataframe, aes_string(x=quo_name(xvalue), y=quo_name(yvalue), color=quo_name(colorvalue)))+\n    geom_point()+\n    geom_errorbar(aes(ymin = !!yvalue - !!error, \n                      ymax = !!yvalue + !!error),\n                  width=0.7, colour=\"black\", size=0.7) +\n    \n    scale_color_viridis(discrete=TRUE)+\n    theme_minimal()+\n    theme(\n      panel.background = element_rect(fill = \"white\"),  # Set white background\n      panel.grid.major = element_blank(),  # Remove grid lines\n      panel.grid.minor = element_blank(),  # Remove grid lines\n      axis.text = element_text(size = 9),  # Increase font size of axis text\n      axis.title.y = element_text(size = 9,face = \"bold\"),  # Make y-axis label bold and italic\n      axis.text.y = element_text(color = \"black\", size = 9),  # Make x-axis text bold\n      axis.title.x = element_text(size = 10,face = \"bold\"),\n      axis.text.x = element_text(color = \"black\", size = 9, angle = 45, hjust=1),  # Make x-axis text bold\n      axis.ticks.x = element_line(color = \"black\"),  # Add ticks to x-axis in black color\n      axis.ticks.y = element_line(color = \"black\"),  # Add ticks to y-axis in black color\n      plot.margin = margin(0.5, 0.5, 0.4, 0.5, \"cm\"),  # Set plot margins\n      legend.text=element_text(size=9),\n      legend.background = element_rect(fill=\"white\",\n                                     size=0.5, linetype=\"solid\", \n                                     colour =\"black\"),\n      legend.title = element_blank(),\n    )\n####### TRIED TO MAKE ERROR AN OPTIONAL, SO IT ONLY PLOTS ERRORBARS IF ERROR IS NOT NULL ##########\n  #if(!is.null(error)) {\n    #error &lt;- enquo(error)   # Capture error as a quosure\n    #p &lt;- p + geom_errorbar(aes(ymin = !!yvalue - !!error, \n    #                           ymax = !!yvalue + !!error),\n    #                       width=0.7, colour=\"black\", size=0.7)\n    #}\n####### DOES NOT WORK #############################\n  return(p)\n}\n\n\nCalculate concentration from calibration curve: \\(Concentration =\\frac{Response-Intercept}{Slope}\\)\n\n\ncal_conc &lt;- function(response, intercept, slope){\n  concentration &lt;- (response-intercept)/slope\n  return(concentration)\n}"
  },
  {
    "objectID": "project.html#target-compounds-from-unifi",
    "href": "project.html#target-compounds-from-unifi",
    "title": "4  Project",
    "section": "4.3 Target Compounds from UNIFI",
    "text": "4.3 Target Compounds from UNIFI\nThis section is for data analysis when target compounds data (e.g. m/z, RT, DT, CCS, and intensity) has been obtained directly from UNIFI. Hence, the data has NOT been processed with e.g MS-DIAL, so there is not need to “find” the target compounds in a long list of features.\nImporting the data\nTwo data sets are imported, one containing the measured data (data_hrms) and one with information of the target compounds (target_compounds), which contains the molecular formula, monoisotopic mass, and theoretical mass of the different adducts ([M+H]+, [M+Na]+, [M+NH4]+, and [M-H]-).\n\ndata_hrms &lt;- read_excel(\"Data_HRMS_Format_TEST.xlsx\", \n    sheet = \"Data_StDB\")\n#glimpse(data_hrms)\ntarget_compounds &lt;- read_excel(\"Target_Compounds_StDB.xlsx\")\n#glimpse(target_compounds)\n\nCalculate the Mass Accuracy with the mass_error() function depending on which adduct the compound was found as and add the results in the data_hrms data frame.\n\n#If the compounds in target_compounds and data_hrms are in the same order\ndata_hrms &lt;- data_hrms |&gt; \n    mutate(Mass_accuracy=case_when(Adduct == \"[M+H]+\" ~ mass_error(target_compounds$`[M+H]+`, Mass_to_Charge_Ratio),\n                              Adduct == \"[M+Na]+\" ~ mass_error(target_compounds$`[M+Na]+`, Mass_to_Charge_Ratio),\n                              Adduct == \"[M+NH4]+\" ~ mass_error(target_compounds$`[M+NH4]+`, Mass_to_Charge_Ratio),\n                             Adduct == \"[M-H]-\" ~ mass_error(target_compounds$`[M-H]-`,Mass_to_Charge_Ratio) )) \n\n\n#If the compounds in target_compounds and data_hrms are not in the same order, can join the two data frames according to the compounds name and then calculate mass accuracy\ndata_hrms &lt;- inner_join(data_hrms, target_compounds, by = c(\"Compound\" = \"Item name\")) |&gt; \n    mutate(Mass_accuracy=case_when(Adduct == \"[M+H]+\" ~ mass_error(`[M+H]+`, Mass_to_Charge_Ratio),\n                              Adduct == \"[M+Na]+\" ~ mass_error(`[M+Na]+`, Mass_to_Charge_Ratio),\n                              Adduct == \"[M+NH4]+\" ~ mass_error(`[M+NH4]+`, Mass_to_Charge_Ratio),\n                             Adduct == \"[M-H]-\" ~ mass_error(`[M-H]-`,Mass_to_Charge_Ratio) )) |&gt; \n  select(Sample_Item, Replicate, Compound, Adduct, Mass_to_Charge_Ratio, Retention_Time, Drift_Time, CCS, Detector_Counts, Mass_accuracy)\n\nCalculate the Average and SEM of m/z, Mass Accuracy, RT, DT, CCS, and intensity for each compound in each type of sample (Sample Item) with the mean() and SEM() functions.\n\ndata_hrms$Sample_Item &lt;- factor(data_hrms$Sample_Item, levels=unique(data_hrms$Sample_Item)) #Convert Sample_Item to factor to be able to keep the original order of the data\n\ndata_hrms_average &lt;-data_hrms |&gt;  filter(!is.na(Mass_to_Charge_Ratio))|&gt; \n  group_by(Sample_Item, Compound) |&gt; \n  summarise(Average_MZ=round(mean(Mass_to_Charge_Ratio, na.rm =TRUE),digits=3),\n            SEM_MZ=stderror(Mass_to_Charge_Ratio),\n            Average_MassAccuracy=round(mean(Mass_accuracy, na.rm =TRUE),digits=3),\n            SEM_MassAccuracy=stderror(Mass_accuracy),\n            Average_RT=round(mean(Retention_Time, na.rm =TRUE),digits=3),\n            SEM_RT=stderror(Retention_Time),\n            Average_DT=round(mean(Drift_Time, na.rm =TRUE),digits=3),\n            SEM_DT=stderror(Drift_Time),\n            Average_CCS=round(mean(CCS, na.rm =TRUE),digits=3),\n            SEM_CCS=stderror(CCS),\n            Average_intensity=round(mean(Detector_Counts, na.rm =TRUE),digits=3),\n            SEM_intensity=stderror(Detector_Counts)) |&gt; \n  ungroup() |&gt; \n  group_by(Compound)\n\n`summarise()` has grouped output by 'Sample_Item'. You can override using the\n`.groups` argument.\n\n#glimpse(data_hrms_average)\n\nPlots using the bar_plot function.\n\nbar_plot(data_hrms_average, Compound, Average_MZ, Sample_Item, SEM_MZ)+\n  labs(y = \"Average Mass-To-Charge Ratio\", x=\"\")+\n  scale_y_continuous(expand = expansion(add=c(0,30)))\n\nWarning: `aes_string()` was deprecated in ggplot2 3.0.0.\nℹ Please use tidy evaluation idioms with `aes()`.\nℹ See also `vignette(\"ggplot2-in-packages\")` for more information.\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\nWarning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0.\nℹ Please use the `linewidth` argument instead.\n\n\n\n\nbar_plot(data_hrms_average, Compound, Average_RT, Sample_Item, SEM_RT)+\n  labs(y = \"Average Retention time [min]\", x=\"\")+\n  scale_y_continuous(expand = expansion(add=c(0,1)))\n\n\n\nbar_plot(data_hrms_average, Compound, Average_DT, Sample_Item, SEM_DT)+\n  labs(y = \"Average Drift time [ms]\", x=\"\")+\n  scale_y_continuous(expand = expansion(add=c(0,0.11)))\n\n\n\nbar_plot(data_hrms_average, Compound, Average_CCS, Sample_Item, SEM_CCS)+\n  labs(y = expression(\"Average CCS [Å\"^\"2\"~\"]\"), x=\"\")+\n  scale_y_continuous(expand = expansion(add=c(0,10)))\n\n\n\nbar_plot(data_hrms_average, Compound, Average_intensity, Sample_Item, SEM_intensity)+\n  labs(y = \"Average Intensity\", x=\"\")+\n  scale_y_continuous(expand = expansion(add=c(0,100)))\n\n\n\n\nPlots using the scatter_plot function.\n\nscatter_plot(data_hrms_average, Average_MZ, Average_RT, Compound, SEM_RT)+\n  geom_text_repel(data=data_hrms_average |&gt; distinct(Compound, .keep_all=TRUE),\n                   aes(label=Compound),\n                     size = 2.5,\n                     point.padding = NA, # additional padding around each point\n                     min.segment.length = 0, # draw all line segments\n                     force=2,\n                     nudge_x=3, nudge_y=0.1,\n                     color=\"black\"\n                   )+\n  labs(y = \"Average Retention time [min]\", x=expression(paste(\"Theoretical \",italic(\"m/z\"), \" values\")))+\n  theme(legend.position = \"none\")\n\n\n\nscatter_plot(data_hrms_average, Average_MZ, Average_CCS, Compound, SEM_CCS)+\n  labs(y = \"Average Drift time [min]\", x=expression(paste(\"Theoretical \",italic(\"m/z\"), \" values\")))\n\n\n\n\n\nIf measured samples are standards of different concentrations, calibration curves can be plotted.\nPlotting calibration curves of the concentration vs intensities to be able to visually see the regression. However, to obtain the Standard Error of the Slope and the Slope for calculation of Limit of Detection (LOD), no calibration curve needs to be plotted.\n\n#End of the Sample_Item-names contains the concentrations in ppb, which is added to a new column\ndata_hrms_average &lt;- data_hrms_average |&gt; \n  mutate(Concentration = as.numeric(str_extract(Sample_Item, \"\\\\d+\")))\n\n#Plot the calibrations curves for each compounds in separate plots. To each calibration curve is the R^2 added\nggplot(data=data_hrms_average, mapping=aes(x=Concentration, y=Average_intensity, colour=Compound))+\n  geom_errorbar(aes(ymin=Average_intensity-SEM_intensity, ymax=Average_intensity+SEM_intensity), width=3, size=0.6, colour=\"black\")+\n  geom_point() +\n  geom_smooth(method=\"lm\", \n              size=0.6, \n              se=FALSE, \n              linetype=\"dashed\",\n              fullrange=TRUE,\n              aes(color=Compound))+ \n  stat_cor(aes(label=..rr.label..), label.x=200, size=3, colour=\"black\", r.digits = 5)+ #adds R^2\n  facet_wrap(~ Compound, scales=\"free\")+ #separates the plots for each compound\n  scale_color_viridis(discrete=TRUE)+\n  theme_minimal()+\n  theme(\n    panel.background = element_rect(fill = \"white\"),  # Set white background\n    panel.grid.major = element_blank(),  # Remove grid lines\n    panel.grid.minor = element_blank(),  # Remove grid lines\n    axis.text = element_text(size = 9),  # Increase font size of axis text\n    axis.title.y = element_text(size = 9,face = \"bold\"),  # Make y-axis label bold and italic\n    axis.text.y = element_text(color = \"black\", size = 9),  # Make x-axis text bold\n    axis.title.x = element_text(size = 10,face = \"bold\"),\n    axis.text.x = element_text(color = \"black\", size = 9),  # Make x-axis text bold\n    axis.ticks.x = element_line(color = \"black\"),  # Add ticks to x-axis in black color\n    axis.ticks.y = element_line(color = \"black\"),  # Add ticks to y-axis in black color\n    plot.margin = margin(0.5, 0.5, 0.4, 0.5, \"cm\"),  # Set plot margins\n    legend.position = \"none\"\n)+\n  labs(y = \"Average Intensity\", x=\"Concentration [ppb]\")\n\nWarning: The dot-dot notation (`..rr.label..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(rr.label)` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Computation failed in `stat_cor()`.\nCaused by error in `cor.test.default()`:\n! not enough finite observations\n\n\n\n\n# Obtain the Slope (a) and Intercept (b) for each calibration curve (y=ax+b)\nregression_1 &lt;- data_hrms_average |&gt; \n  group_by(Compound)  |&gt; \n  do(tidy(lm(Average_intensity ~ Concentration, data = .)))  |&gt; \n  filter(term %in% c(\"Concentration\", \"(Intercept)\"))  |&gt; \n  mutate(parameter = if_else(term == \"Concentration\", \"Slope\", \"Intercept\"))  |&gt; \n  select(Compound, parameter, estimate)  |&gt; \n  spread(parameter, estimate)\n\n##### Obtain the Slope (a) for each calibration curve (y=ax+b)#####\n#regression_1 &lt;- data_hrms_average |&gt; \n#  group_by(Compound) |&gt; \n#  do(tidy(lm(Average_intensity ~ Concentration, data = .)))  |&gt; \n#  filter(term == \"Concentration\")  |&gt; \n#  select(Compound, Slope = estimate)\n\n# Obtain the StDErrorY for each calibration curve\nregression_2 &lt;- data_hrms_average |&gt; \n   group_by(Compound) |&gt; \n   do(augment(lm(Average_intensity ~ Concentration, data = .))) |&gt; \n   summarise(StdErrorY = sd(.resid))  |&gt; \n   select(Compound, StdErrorY)\n# Combines the two data frames with Slope and StDErrorY, and calculate the LOD and LOQ for them\nregression_data_hrms_average &lt;- regression_1 |&gt; \n  inner_join(regression_2, join_by(Compound)) |&gt;   \n  mutate(`LOD_[ppb]`= round(3.3*StdErrorY/Slope,digits=3)) |&gt; \n  mutate(`LOQ_[ppb]`= round(10*StdErrorY/Slope,digits=3))\n\n\n#Calculate the concentration from the calibration curve for selected Sample_Item and Replicate\n\nsample &lt;- \"StD_300\"\nnr_replicate &lt;- 1\n\ncal_conc_data_hrms &lt;- data_hrms |&gt; \n  filter(Sample_Item == sample & Replicate == nr_replicate) |&gt;\n  semi_join(regression_data_hrms_average, by = \"Compound\") |&gt; \n  mutate(Calculated_Conc = cal_conc(Detector_Counts, regression_data_hrms_average$Intercept, regression_data_hrms_average$Slope))\n\n\n#Create a table with the calculated concentrations\ngt_tab &lt;- cal_conc_data_hrms |&gt; filter(!is.na(Calculated_Conc))|&gt; \n  select(Compound, Mass_to_Charge_Ratio, Retention_Time, Drift_Time, CCS, Calculated_Conc) |&gt; \n  gt() |&gt;\n  tab_options(table.font.color=\"black\")|&gt; \n  tab_header(\n      title=md(\"**Calculated Concentrations**\"), #**to make bold\n      ) |&gt; \n  fmt_number(columns = c(Mass_to_Charge_Ratio, Retention_Time, Drift_Time, CCS, Calculated_Conc), decimals=3) |&gt;  #to formate numbers, can select specific columns to display certain nr. of deicmals for example. \n  cols_label(\n    Mass_to_Charge_Ratio = md(\"*m/z*\"),\n    Retention_Time = md(\"Retention Time &lt;br&gt;[min]\"),\n    Drift_Time = md(\"Drift Time &lt;br&gt;[ms]\"),\n    CCS = md(\"Å^2^\"),\n    Calculated_Conc = md(\"Calculated Concentrations\")\n  ) \ngt_tab \n\n\n\n\n\n  \n    \n      Calculated Concentrations\n    \n    \n    \n      Compound\n      m/z\n      Retention Time [min]\n      Drift Time [ms]\n      Å2\n      Calculated Concentrations\n    \n  \n  \n    2-aminobenzothiazole\n151.031\n1.970\n2.110\n126.520\n318.219\n    4-Androstene-3,17-dione\n309.181\n4.560\n5.330\n199.330\n280.012\n    Acesulfame\n161.986\n0.500\n2.030\n122.290\n339.575\n    Avobenzone\n333.144\n6.270\n5.410\n201.040\n346.053\n    Benzophenone\n183.079\n4.630\n2.610\n136.290\n279.538\n    Estrone\n271.168\n4.590\n3.900\n164.320\n354.133\n    Ethylparaben\n165.055\n3.680\n2.510\n132.870\n335.132\n    Hydrocortisone\n363.215\n3.990\n4.910\n187.490\n320.619\n    Metformin\n130.107\n0.430\n1.970\n124.750\n310.067\n    Octocrylene\n379.237\n6.100\n5.720\n208.560\n344.356\n    Oleamide\n304.260\n6.620\n4.750\n184.470\n333.817\n    Oxybenzone\n251.066\n5.010\n3.890\n164.410\n417.382\n    Pregnenolone\n317.247\n5.390\n4.560\n179.710\n272.946\n    Progesterone\n337.212\n5.160\n5.640\n206.850\n332.579\n    Testosterone\n289.215\n4.700\n4.240\n172.150\n303.769\n  \n  \n  \n\n\n\n#gt_tab |&gt; gtsave(filename = \"tab_1.html\") #saves the table in HTML format\n#gt_tab |&gt; gtsave(filename = \"tab_1.tex\") #saves the table in LaTEX format\n#gt_tab |&gt; gtsave(filename = \"tab_1.docx\") #saves the table in WORD format"
  },
  {
    "objectID": "project.html#processed-data-ms-dial",
    "href": "project.html#processed-data-ms-dial",
    "title": "4  Project",
    "section": "4.4 Processed Data MS-DIAL",
    "text": "4.4 Processed Data MS-DIAL\nThis section is for data that has been exported from UNIFI and then been processed in MS-DIAL. Hence, the output file contains many features and the target compounds needs to be extracted from the processed output file by comparison with expected data (e.g. theoretical m/z of different adducts)."
  }
]